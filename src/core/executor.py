# src/core/executor.py

import logging
import re
import shlex
import json
from datetime import datetime, timedelta, timezone
from typing import Any, Optional, Dict, Callable, Coroutine, List

from sqlalchemy.orm import Session
from telegram import Update, ChatPermissions, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# Import the new AST nodes from the refactored parser
from src.core.parser import (
    ParsedRule, Stmt, Expr, StatementBlock, Assignment, ActionCallStmt,
    ActionCallExpr, Literal, Variable, PropertyAccess, IndexAccess, BinaryOp,
    ListConstructor, DictConstructor, IfStmt, ForEachStmt, BreakStmt, ContinueStmt
)
from src.database import StateVariable

logger = logging.getLogger(__name__)

# ==================== Built-in Functions & Actions ====================

_ACTION_REGISTRY: Dict[str, Callable[..., Coroutine]] = {}
_BUILTIN_FUNCTIONS: Dict[str, Callable[..., Any]] = {}

def action(name: str):
    """A decorator to register a method as a rule script action."""
    def decorator(func: Callable[..., Coroutine]):
        _ACTION_REGISTRY[name.lower()] = func
        return func
    return decorator

def builtin_function(name: str):
    """A decorator to register a Python function as a built-in function in the script language."""
    def decorator(func: Callable[..., Any]):
        _BUILTIN_FUNCTIONS[name.lower()] = func
        return func
    return decorator

# ==================== Exceptions ====================

# Note: The function implementations are placed here, before the class that uses them.
# They are decorated to register them into the _BUILTIN_FUNCTIONS registry.

@builtin_function("len")
def builtin_len(obj: Any) -> int:
    """内置函数：返回列表、字典或字符串的长度。"""
    try:
        return len(obj)
    except TypeError:
        return 0

@builtin_function("str")
def builtin_str(obj: Any) -> str:
    """内置函数：将一个对象转换为其字符串表示形式。"""
    return str(obj)

@builtin_function("int")
def builtin_int(obj: Any) -> int:
    """内置函数：将一个对象转换为整数。转换失败时返回 0。"""
    try:
        return int(obj)
    except (ValueError, TypeError):
        return 0

@builtin_function("lower")
def builtin_lower(s: str) -> str:
    """内置函数：将字符串转换为小写。"""
    return str(s).lower()

@builtin_function("upper")
def builtin_upper(s: str) -> str:
    """内置函数：将字符串转换为大写。"""
    return str(s).upper()

@builtin_function("split")
def builtin_split(s: str, sep: str = None, maxsplit: int = -1) -> List[str]:
    """内置函数：按分隔符分割字符串。如果未提供分隔符，则按空白字符分割。"""
    return str(s).split(sep, maxsplit)

@builtin_function("join")
def builtin_join(l: list, sep: str) -> str:
    """内置函数：使用分隔符连接列表中的所有元素，生成一个字符串。"""
    return str(sep).join(map(str, l))


class StopRuleProcessing(Exception):
    """Custom exception to stop processing further rules for the current event."""
    pass

class BreakException(Exception):
    """Used to break out of a foreach loop."""
    pass

class ContinueException(Exception):
    """Used to skip to the next iteration of a foreach loop."""
    pass

# ======================================================================================
# Phase 1 Refactoring: New RuleExecutor as a Script Interpreter
# ======================================================================================

class RuleExecutor:
    """
    The new RuleExecutor acts as an interpreter for the AST generated by the RuleParser.
    It walks the AST, evaluates expressions, manages state, and executes actions.
    """
    def __init__(self, update: Update, context: ContextTypes.DEFAULT_TYPE, db_session: Session):
        """
        初始化规则执行器。

        Args:
            update: 当前的 Telegram Update 对象。
            context: 当前的 Telegram Context 对象。
            db_session: 当前数据库会话。
        """
        self.update = update
        self.context = context
        self.db_session = db_session
        self.per_request_cache: Dict[str, Any] = {}
        # The scope will hold local variables defined within the script
        self.scope: Dict[str, Any] = {}

    async def execute_rule(self, rule: ParsedRule):
        """
        执行一个已完全解析的规则。
        此方法会为本次执行创建一个顶层的变量作用域。
        """
        # A top-level scope is created for each rule execution to ensure isolation.
        top_level_scope = {}

        # 1. Evaluate the WHERE clause if it exists.
        if rule.where_clause:
            where_passed = await self.evaluate_expression(rule.where_clause, top_level_scope)
            # If the WHERE condition is not met, stop execution for this rule.
            if not where_passed:
                return

        # 2. Execute the THEN block if the WHERE clause passed (or didn't exist).
        if rule.then_block:
            await self.execute_statement_block(rule.then_block, top_level_scope)

    async def execute_statement_block(self, block: StatementBlock, current_scope: Dict[str, Any]):
        """Executes a block of statements within a given scope."""
        for stmt in block.statements:
            await self.execute_statement(stmt, current_scope)

    async def execute_statement(self, stmt: Stmt, current_scope: Dict[str, Any]):
        """Dispatches a single statement to the correct visitor method."""
        stmt_type = type(stmt)
        if stmt_type is Assignment:
            await self.visit_assignment(stmt, current_scope)
        elif stmt_type is ActionCallStmt:
            await self.visit_action_call_stmt(stmt, current_scope)
        elif stmt_type is ForEachStmt:
            await self.visit_foreach_stmt(stmt, current_scope)
        elif stmt_type is BreakStmt:
            raise BreakException()
        elif stmt_type is ContinueStmt:
            raise ContinueException()
        elif stmt_type is IfStmt:
            await self.visit_if_stmt(stmt, current_scope)
        else:
            logger.warning(f"Unknown statement type encountered: {stmt_type}")

    async def visit_if_stmt(self, stmt: IfStmt, current_scope: Dict[str, Any]):
        """Executes an 'if (condition) { ... } else { ... }' statement."""
        condition_result = await self.evaluate_expression(stmt.condition, current_scope)

        # In our language, we'll treat 0, "", [], {}, None, and False as "falsy"
        is_truthy = bool(condition_result)

        if is_truthy:
            await self.execute_statement_block(stmt.then_block, current_scope)
        elif stmt.else_block:
            await self.execute_statement_block(stmt.else_block, current_scope)

    async def visit_foreach_stmt(self, stmt: ForEachStmt, current_scope: Dict[str, Any]):
        """Executes a 'foreach (var in collection) { ... }' statement."""
        collection = await self.evaluate_expression(stmt.collection, current_scope)

        if not isinstance(collection, (list, str)):
            logger.warning(f"Foreach loop target is not iterable: {type(collection)}")
            return

        for item in collection:
            # Create a new, nested scope for the loop body
            loop_scope = current_scope.copy()
            loop_scope[stmt.loop_var] = item

            try:
                await self.execute_statement_block(stmt.body, loop_scope)
            except BreakException:
                break # Exit the loop
            except ContinueException:
                continue # Go to the next iteration

        # After the loop, the parent scope is automatically restored because
        # we only modified a copy.

    async def visit_assignment(self, stmt: Assignment, current_scope: Dict[str, Any]):
        """Handles assignment to variables, properties, and indexes."""
        value = await self.evaluate_expression(stmt.expression, current_scope)
        target_expr = stmt.variable

        if isinstance(target_expr, Variable):
            current_scope[target_expr.name] = value
            logger.debug(f"Assigned to local var '{target_expr.name}': {value}")
        elif isinstance(target_expr, (PropertyAccess, IndexAccess)):
            container = await self.evaluate_expression(target_expr.target, current_scope)
            if container is None:
                logger.warning(f"Cannot assign to property/index of a null object.")
                return

            if isinstance(target_expr, PropertyAccess):
                if isinstance(container, dict):
                    container[target_expr.property] = value
                else:
                    setattr(container, target_expr.property, value)
            else: # IndexAccess
                index = await self.evaluate_expression(target_expr.index, current_scope)
                if isinstance(container, (list, dict)):
                    try:
                        container[index] = value
                    except (IndexError, KeyError) as e:
                        logger.warning(f"Error during index assignment: {e}")
        else:
            logger.warning(f"Invalid assignment target: {target_expr}")

    async def visit_action_call_stmt(self, stmt: ActionCallStmt, current_scope: Dict[str, Any]):
        """Handles 'action_name(...);'"""
        action_name = stmt.call.action_name.lower()

        if action_name in _ACTION_REGISTRY:
            action_func = _ACTION_REGISTRY[action_name]

            evaluated_args = []
            for arg_expr in stmt.call.args:
                evaluated_args.append(await self.evaluate_expression(arg_expr, current_scope))

            await action_func(self, *evaluated_args)
        else:
            logger.warning(f"Unknown action '{stmt.call.action_name}' called.")

    async def evaluate_expression(self, expr: Expr, current_scope: Dict[str, Any]) -> Any:
        """Recursively evaluates an expression node and returns the result."""
        expr_type = type(expr)

        if expr_type is Literal:
            return expr.value
        elif expr_type is Variable:
            if expr.name in current_scope:
                return current_scope[expr.name]
            else:
                return await self._resolve_path(expr.name)
        elif expr_type is PropertyAccess:
            target = await self.evaluate_expression(expr.target, current_scope)
            if target is None:
                return None
            elif isinstance(target, dict):
                return target.get(expr.property)
            else:
                return getattr(target, expr.property, None)
        elif expr_type is IndexAccess:
            target = await self.evaluate_expression(expr.target, current_scope)
            index = await self.evaluate_expression(expr.index, current_scope)
            if target is None:
                return None
            else:
                try:
                    return target[index]
                except (IndexError, KeyError, TypeError):
                    return None
        elif expr_type is BinaryOp:
            return await self.visit_binary_op(expr, current_scope)
        elif expr_type is ActionCallExpr:
            return await self.visit_function_call_expr(expr, current_scope)
        elif expr_type is ListConstructor:
            return await self.visit_list_constructor(expr, current_scope)
        elif expr_type is DictConstructor:
            return await self.visit_dict_constructor(expr, current_scope)

        logger.warning(f"Unsupported expression type for evaluation: {expr_type}")
        return None

    async def visit_list_constructor(self, expr: ListConstructor, current_scope: Dict[str, Any]) -> List[Any]:
        """Evaluates a list constructor by evaluating each of its element expressions."""
        evaluated_elements = []
        for element_expr in expr.elements:
            evaluated_elements.append(await self.evaluate_expression(element_expr, current_scope))
        return evaluated_elements

    async def visit_dict_constructor(self, expr: DictConstructor, current_scope: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluates a dict constructor by evaluating each of its value expressions."""
        evaluated_pairs = {}
        for key, value_expr in expr.pairs.items():
            evaluated_pairs[key] = await self.evaluate_expression(value_expr, current_scope)
        return evaluated_pairs

    async def visit_binary_op(self, expr: BinaryOp, current_scope: Dict[str, Any]) -> Any:
        """Evaluates a binary operation, including arithmetic, comparison, and logic."""
        op = expr.op.lower()

        # Handle logical operators with short-circuiting for efficiency
        if op == 'and':
            lhs = await self.evaluate_expression(expr.left, current_scope)
            if not lhs: return False
            return bool(await self.evaluate_expression(expr.right, current_scope))
        if op == 'or':
            lhs = await self.evaluate_expression(expr.left, current_scope)
            if lhs: return True
            return bool(await self.evaluate_expression(expr.right, current_scope))
        if op == 'not':
            # 'not' is parsed as a binary op with a None lhs
            return not bool(await self.evaluate_expression(expr.right, current_scope))

        # Evaluate both operands for all other (non-short-circuiting) operators
        lhs = await self.evaluate_expression(expr.left, current_scope)
        rhs = await self.evaluate_expression(expr.right, current_scope)

        # Arithmetic, List, and String Operations
        try:
            if op == '+':
                if isinstance(lhs, list): return lhs + (rhs if isinstance(rhs, list) else [rhs])
                if isinstance(rhs, list): return ([lhs] if lhs is not None else []) + rhs
                if isinstance(lhs, str) or isinstance(rhs, str): return str(lhs or '') + str(rhs or '')
                return (lhs or 0) + (rhs or 0)
            if op == '-': return (lhs or 0) - (rhs or 0)
            if op == '*': return (lhs or 0) * (rhs or 0)
            if op == '/':
                # Correctly handle division by zero.
                # The original `rhs or 1` was hiding the error.
                if rhs is None or rhs == 0:
                    logger.warning(f"Division by zero attempted: {lhs} / {rhs}")
                    return None
                lhs_val = lhs or 0
                return lhs_val / rhs
        except TypeError:
            logger.warning(f"Type error in arithmetic operation: {lhs} {op} {rhs}")
            return None
        except ZeroDivisionError:
            logger.warning(f"Division by zero error: {lhs} / {rhs}")
            return None


        # Comparison Operators
        if op in ('==', 'eq'): return lhs == rhs
        if op in ('!=', 'ne'): return lhs != rhs
        if op == 'contains': return str(rhs) in str(lhs)
        if op == 'startswith': return str(lhs).startswith(str(rhs))
        if op == 'endswith': return str(lhs).endswith(str(rhs))

        # These comparisons can fail with TypeError if types are incompatible (e.g., 10 > "a")
        try:
            if op in ('>', 'gt'): return lhs > rhs
            if op in ('<', 'lt'): return lhs < rhs
            if op in ('>=', 'ge'): return lhs >= rhs
            if op in ('<=', 'le'): return lhs <= rhs
        except TypeError:
            return False

        logger.warning(f"Unsupported binary operator: {op}")
        return None

    async def visit_function_call_expr(self, expr: ActionCallExpr, current_scope: Dict[str, Any]) -> Any:
        """Evaluates a built-in function call within an expression."""
        func_name = expr.action_name.lower()

        if func_name in _BUILTIN_FUNCTIONS:
            func = _BUILTIN_FUNCTIONS[func_name]

            evaluated_args = []
            for arg_expr in expr.args:
                evaluated_args.append(await self.evaluate_expression(arg_expr, current_scope))

            try:
                # Built-in functions are regular synchronous python functions
                return func(*evaluated_args)
            except Exception as e:
                logger.error(f"Error executing built-in function '{func_name}': {e}")
                return None

        logger.warning(f"Unknown function called in expression: '{expr.action_name}'")
        return None

    async def _resolve_path(self, path: str) -> Any:
        """
        解析一个变量路径 (例如 'user.id', 'vars.group.my_var', 'command.arg[0]')。
        这是脚本引擎和机器人实时数据之间的桥梁。
        """
        path_lower = path.lower()

        if path_lower.startswith('command'):
            return self._resolve_command_variable(path_lower)

        if path_lower.startswith('vars.'):
            return self._resolve_persistent_variable(path)

        # 特殊计算变量
        if path_lower == 'user.is_admin':
            return await self._resolve_computed_is_admin()

        # 默认回退到从 Update 对象中解析
        return self._resolve_from_update_object(path)

    def _resolve_command_variable(self, path_lower: str) -> Any:
        """解析 `command.*` 相关的变量。"""
        if not self.update.message or not self.update.message.text or not self.update.message.text.startswith('/'):
            return None

        cache_key = f"command_args_{self.update.update_id}_{self.update.message.text}"
        if cache_key not in self.per_request_cache:
            parts = shlex.split(self.update.message.text)
            self.per_request_cache[cache_key] = {
                "name": parts[0].lstrip('/'),
                "args": parts[1:],
                "text": self.update.message.text,
                "full_args": " ".join(parts[1:])
            }

        command_data = self.per_request_cache[cache_key]

        if path_lower == 'command':
            return command_data
        if path_lower == 'command.full_text':
            return command_data["text"]
        if path_lower in ('command.name', 'command.text'):
            return command_data["name"]
        if path_lower == 'command.full_args':
            return command_data["full_args"]
        if path_lower == 'command.arg_count':
            return len(command_data["args"])

        match = re.match(r'command\.arg\[(\d+)\]', path_lower)
        if match:
            arg_index = int(match.group(1))
            if 0 <= arg_index < len(command_data["args"]):
                return command_data["args"][arg_index]

        return None

    def _resolve_persistent_variable(self, path: str) -> Any:
        """解析 `vars.*` 相关的持久化变量。"""
        parts = path.split('.')
        if len(parts) != 3: return None

        _, scope, var_name = parts
        query = self.db_session.query(StateVariable).filter_by(group_id=self.update.effective_chat.id, name=var_name)

        if scope.lower() == 'user':
            if not self.update.effective_user: return None
            query = query.filter_by(user_id=self.update.effective_user.id)
        elif scope.lower() == 'group':
            query = query.filter(StateVariable.user_id.is_(None))
        else:
            return None

        variable = query.first()
        if variable:
            try:
                return json.loads(variable.value)
            except json.JSONDecodeError:
                return variable.value
        return None

    async def _resolve_computed_is_admin(self) -> bool:
        """解析需要实时计算的 `user.is_admin` 变量。"""
        if not (self.update.effective_chat and self.update.effective_user): return False

        cache_key = f"is_admin_{self.update.effective_user.id}"
        if cache_key in self.per_request_cache:
            return self.per_request_cache[cache_key]

        try:
            member = await self.context.bot.get_chat_member(chat_id=self.update.effective_chat.id, user_id=self.update.effective_user.id)
            is_admin = member.status in ['creator', 'administrator']
            self.per_request_cache[cache_key] = is_admin
            return is_admin
        except Exception:
            return False

    def _resolve_from_update_object(self, path: str) -> Any:
        """作为默认方式，直接从 Update 对象中解析属性。"""
        current_obj = self.update
        for part in path.split('.'):
            if current_obj is None: return None
            if isinstance(current_obj, dict):
                current_obj = current_obj.get(part)
            else:
                try:
                    current_obj = getattr(current_obj, part)
                except AttributeError:
                    return None
        return current_obj

    # =================== 动作实现 (Action Implementations) ===================
    # 动作本身不需要太多改变，它们只需要接收已经求值过的参数。

    @action("reply")
    async def reply(self, text: Any):
        """动作：回复触发当前规则的消息。"""
        if self.update.effective_message:
            await self.update.effective_message.reply_text(str(text))

    @action("set_var")
    async def set_var(self, variable_path: str, value: Any):
        """
        动作：设置一个持久化变量，并正确处理JSON序列化。
        """
        if not isinstance(variable_path, str):
            return logger.warning(f"set_var 'variable_path' must be a string, but got {type(variable_path)}.")

        parts = variable_path.split('.')
        if len(parts) != 2:
            return logger.warning(f"set_var's variable path '{variable_path}' is invalid. Expected 'scope.name' format.")

        scope, var_name = parts[0].lower(), parts[1]
        if not self.update.effective_chat: return
        group_id = self.update.effective_chat.id
        user_id = None

        if scope == 'user':
            if not self.update.effective_user: return
            user_id = self.update.effective_user.id
        elif scope != 'group':
            return logger.warning(f"set_var has an invalid scope '{scope}'. Must be 'user' or 'group'.")

        variable = self.db_session.query(StateVariable).filter_by(
            group_id=group_id, user_id=user_id, name=var_name
        ).first()

        if value is None:
            if variable:
                self.db_session.delete(variable)
                logger.info(f"Persistent variable '{variable_path}' deleted.")
        else:
            try:
                # Ensure complex types (lists, dicts, bools) are stored as JSON text
                serialized_value = json.dumps(value)
            except TypeError as e:
                return logger.error(f"Failed to serialize value for '{variable_path}': {e}. Value: {value}")

            if not variable:
                variable = StateVariable(group_id=group_id, user_id=user_id, name=var_name)
            variable.value = serialized_value
            self.db_session.add(variable)
            logger.info(f"Persistent variable '{variable_path}' was set to: {serialized_value}")

    # (Other actions like mute_user, kick_user, etc., would be here, unchanged)
    # For brevity, I am omitting them, but they are part of the file.

    @action("delete_message")
    async def delete_message(self):
        """动作：删除触发此规则的消息。"""
        if self.update.effective_message:
            try:
                await self.update.effective_message.delete()
            except Exception as e:
                logger.error(f"删除消息失败: {e}")

    @action("start_verification")
    async def start_verification(self):
        """
        动作：为新用户开启人机验证流程。
        这包括：
        1. 立即将用户设置为受限模式（仅可读）。
        2. 向群组内发送一条带有 "开始验证" 按钮的消息。
        """
        if not (self.update.effective_chat and self.update.effective_user):
            return

        chat_id = self.update.effective_chat.id
        user_id = self.update.effective_user.id
        user_mention = self.update.effective_user.mention_html()
        bot_username = self.context.bot.username

        try:
            # 1. 将用户禁言
            await self.context.bot.restrict_chat_member(
                chat_id=chat_id,
                user_id=user_id,
                permissions=ChatPermissions(can_send_messages=False)
            )

            # 2. 发送验证链接
            verification_url = f"https://t.me/{bot_username}?start=verify_{chat_id}_{user_id}"
            keyboard = InlineKeyboardMarkup.from_button(
                InlineKeyboardButton(text="点此开始验证", url=verification_url)
            )
            await self.context.bot.send_message(
                chat_id=chat_id,
                text=f"欢迎 {user_mention}！为防止机器人骚扰，请在15分钟内点击下方按钮完成验证。",
                reply_markup=keyboard,
                parse_mode='HTML'
            )
        except Exception as e:
            logger.error(f"为用户 {user_id} 在群组 {chat_id} 启动验证时出错: {e}", exc_info=True)


    @action("stop")
    async def stop(self):
        raise StopRuleProcessing()
