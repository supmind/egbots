# src/core/executor.py

import logging
import re
import shlex
import json
from datetime import datetime, timedelta, timezone
from typing import Any, Optional, Dict, Callable, Coroutine, List

from sqlalchemy.orm import Session
from telegram import Update, ChatPermissions, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# Import the new AST nodes from the refactored parser
from src.core.parser import (
    ParsedRule, Stmt, Expr, StatementBlock, Assignment, ActionCallStmt,
    ActionCallExpr, Literal, Variable, PropertyAccess, IndexAccess, BinaryOp,
    ListConstructor, DictConstructor, IfStmt, ForEachStmt, BreakStmt, ContinueStmt
)
from src.database import StateVariable

logger = logging.getLogger(__name__)

# ==================== Built-in Functions & Actions ====================

_ACTION_REGISTRY: Dict[str, Callable[..., Coroutine]] = {}
_BUILTIN_FUNCTIONS: Dict[str, Callable[..., Any]] = {}

def action(name: str):
    """A decorator to register a method as a rule script action."""
    def decorator(func: Callable[..., Coroutine]):
        _ACTION_REGISTRY[name.lower()] = func
        return func
    return decorator

def builtin_function(name: str):
    """A decorator to register a Python function as a built-in function in the script language."""
    def decorator(func: Callable[..., Any]):
        _BUILTIN_FUNCTIONS[name.lower()] = func
        return func
    return decorator

# ==================== Exceptions ====================

# Note: The function implementations are placed here, before the class that uses them.
# They are decorated to register them into the _BUILTIN_FUNCTIONS registry.

@builtin_function("len")
def builtin_len(obj: Any) -> int:
    """Returns the length of a list, dictionary, or string."""
    try:
        return len(obj)
    except TypeError:
        return 0

@builtin_function("str")
def builtin_str(obj: Any) -> str:
    """Converts an object to its string representation."""
    return str(obj)

@builtin_function("int")
def builtin_int(obj: Any) -> int:
    """Converts an object to an integer. Returns 0 on failure."""
    try:
        return int(obj)
    except (ValueError, TypeError):
        return 0

@builtin_function("lower")
def builtin_lower(s: str) -> str:
    """Converts a string to lowercase."""
    return str(s).lower()

@builtin_function("upper")
def builtin_upper(s: str) -> str:
    """Converts a string to uppercase."""
    return str(s).upper()

@builtin_function("split")
def builtin_split(s: str, sep: str = None, maxsplit: int = -1) -> List[str]:
    """Splits a string by a separator. If sep is not provided, splits by whitespace."""
    return str(s).split(sep, maxsplit)

@builtin_function("join")
def builtin_join(l: list, sep: str) -> str:
    """Joins a list of strings with a separator."""
    return str(sep).join(map(str, l))


class StopRuleProcessing(Exception):
    """Custom exception to stop processing further rules for the current event."""
    pass

class BreakException(Exception):
    """Used to break out of a foreach loop."""
    pass

class ContinueException(Exception):
    """Used to skip to the next iteration of a foreach loop."""
    pass

# ======================================================================================
# Phase 1 Refactoring: New RuleExecutor as a Script Interpreter
# ======================================================================================

class RuleExecutor:
    """
    The new RuleExecutor acts as an interpreter for the AST generated by the RuleParser.
    It walks the AST, evaluates expressions, manages state, and executes actions.
    """
    def __init__(self, update: Update, context: ContextTypes.DEFAULT_TYPE, db_session: Session):
        self.update = update
        self.context = context
        self.db_session = db_session
        self.per_request_cache: Dict[str, Any] = {}
        # The scope will hold local variables defined within the script
        self.scope: Dict[str, Any] = {}

    async def execute_rule(self, rule: ParsedRule):
        """
        Executes a fully parsed rule.
        It creates a top-level scope for the execution.
        """
        # A top-level scope is created for each rule execution to ensure isolation.
        top_level_scope = {}

        # 1. Evaluate the WHERE clause if it exists.
        if rule.where_clause:
            where_passed = await self.evaluate_expression(rule.where_clause, top_level_scope)
            # If the WHERE condition is not met, stop execution for this rule.
            if not where_passed:
                return

        # 2. Execute the THEN block if the WHERE clause passed (or didn't exist).
        if rule.then_block:
            await self.execute_statement_block(rule.then_block, top_level_scope)

    async def execute_statement_block(self, block: StatementBlock, current_scope: Dict[str, Any]):
        """Executes a block of statements within a given scope."""
        for stmt in block.statements:
            await self.execute_statement(stmt, current_scope)

    async def execute_statement(self, stmt: Stmt, current_scope: Dict[str, Any]):
        """Dispatches a single statement to the correct visitor method."""
        stmt_type = type(stmt)
        if stmt_type is Assignment:
            await self.visit_assignment(stmt, current_scope)
        elif stmt_type is ActionCallStmt:
            await self.visit_action_call_stmt(stmt, current_scope)
        elif stmt_type is ForEachStmt:
            await self.visit_foreach_stmt(stmt, current_scope)
        elif stmt_type is BreakStmt:
            raise BreakException()
        elif stmt_type is ContinueStmt:
            raise ContinueException()
        elif stmt_type is IfStmt:
            await self.visit_if_stmt(stmt, current_scope)
        else:
            logger.warning(f"Unknown statement type encountered: {stmt_type}")

    async def visit_if_stmt(self, stmt: IfStmt, current_scope: Dict[str, Any]):
        """Executes an 'if (condition) { ... } else { ... }' statement."""
        condition_result = await self.evaluate_expression(stmt.condition, current_scope)

        # In our language, we'll treat 0, "", [], {}, None, and False as "falsy"
        is_truthy = bool(condition_result)

        if is_truthy:
            await self.execute_statement_block(stmt.then_block, current_scope)
        elif stmt.else_block:
            await self.execute_statement_block(stmt.else_block, current_scope)

    async def visit_foreach_stmt(self, stmt: ForEachStmt, current_scope: Dict[str, Any]):
        """Executes a 'foreach (var in collection) { ... }' statement."""
        collection = await self.evaluate_expression(stmt.collection, current_scope)

        if not isinstance(collection, (list, str)):
            logger.warning(f"Foreach loop target is not iterable: {type(collection)}")
            return

        for item in collection:
            # Create a new, nested scope for the loop body
            loop_scope = current_scope.copy()
            loop_scope[stmt.loop_var] = item

            try:
                await self.execute_statement_block(stmt.body, loop_scope)
            except BreakException:
                break # Exit the loop
            except ContinueException:
                continue # Go to the next iteration

        # After the loop, the parent scope is automatically restored because
        # we only modified a copy.

    async def visit_assignment(self, stmt: Assignment, current_scope: Dict[str, Any]):
        """Handles assignment to variables, properties, and indexes."""
        value = await self.evaluate_expression(stmt.expression, current_scope)
        target_expr = stmt.variable

        if isinstance(target_expr, Variable):
            current_scope[target_expr.name] = value
            logger.debug(f"Assigned to local var '{target_expr.name}': {value}")
        elif isinstance(target_expr, (PropertyAccess, IndexAccess)):
            container = await self.evaluate_expression(target_expr.target, current_scope)
            if container is None:
                logger.warning(f"Cannot assign to property/index of a null object.")
                return

            if isinstance(target_expr, PropertyAccess):
                if isinstance(container, dict):
                    container[target_expr.property] = value
                else:
                    setattr(container, target_expr.property, value)
            else: # IndexAccess
                index = await self.evaluate_expression(target_expr.index, current_scope)
                if isinstance(container, (list, dict)):
                    try:
                        container[index] = value
                    except (IndexError, KeyError) as e:
                        logger.warning(f"Error during index assignment: {e}")
        else:
            logger.warning(f"Invalid assignment target: {target_expr}")

    async def visit_action_call_stmt(self, stmt: ActionCallStmt, current_scope: Dict[str, Any]):
        """Handles 'action_name(...);'"""
        action_name = stmt.call.action_name.lower()

        if action_name in _ACTION_REGISTRY:
            action_func = _ACTION_REGISTRY[action_name]

            evaluated_args = []
            for arg_expr in stmt.call.args:
                evaluated_args.append(await self.evaluate_expression(arg_expr, current_scope))

            await action_func(self, *evaluated_args)
        else:
            logger.warning(f"Unknown action '{stmt.call.action_name}' called.")

    async def evaluate_expression(self, expr: Expr, current_scope: Dict[str, Any]) -> Any:
        """Recursively evaluates an expression node and returns the result."""
        expr_type = type(expr)

        if expr_type is Literal:
            return expr.value
        elif expr_type is Variable:
            if expr.name in current_scope:
                return current_scope[expr.name]
            else:
                return await self._resolve_path(expr.name)
        elif expr_type is PropertyAccess:
            target = await self.evaluate_expression(expr.target, current_scope)
            if target is None:
                return None
            elif isinstance(target, dict):
                return target.get(expr.property)
            else:
                return getattr(target, expr.property, None)
        elif expr_type is IndexAccess:
            target = await self.evaluate_expression(expr.target, current_scope)
            index = await self.evaluate_expression(expr.index, current_scope)
            if target is None:
                return None
            else:
                try:
                    return target[index]
                except (IndexError, KeyError, TypeError):
                    return None
        elif expr_type is BinaryOp:
            return await self.visit_binary_op(expr, current_scope)
        elif expr_type is ActionCallExpr:
            return await self.visit_function_call_expr(expr, current_scope)
        elif expr_type is ListConstructor:
            return await self.visit_list_constructor(expr, current_scope)
        elif expr_type is DictConstructor:
            return await self.visit_dict_constructor(expr, current_scope)

        logger.warning(f"Unsupported expression type for evaluation: {expr_type}")
        return None

    async def visit_list_constructor(self, expr: ListConstructor, current_scope: Dict[str, Any]) -> List[Any]:
        """Evaluates a list constructor by evaluating each of its element expressions."""
        evaluated_elements = []
        for element_expr in expr.elements:
            evaluated_elements.append(await self.evaluate_expression(element_expr, current_scope))
        return evaluated_elements

    async def visit_dict_constructor(self, expr: DictConstructor, current_scope: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluates a dict constructor by evaluating each of its value expressions."""
        evaluated_pairs = {}
        for key, value_expr in expr.pairs.items():
            evaluated_pairs[key] = await self.evaluate_expression(value_expr, current_scope)
        return evaluated_pairs

    async def visit_binary_op(self, expr: BinaryOp, current_scope: Dict[str, Any]) -> Any:
        """Evaluates a binary operation, including arithmetic, comparison, and logic."""
        op = expr.op.lower()

        # Handle logical operators with short-circuiting for efficiency
        if op == 'and':
            lhs = await self.evaluate_expression(expr.left, current_scope)
            if not lhs: return False
            return bool(await self.evaluate_expression(expr.right, current_scope))
        if op == 'or':
            lhs = await self.evaluate_expression(expr.left, current_scope)
            if lhs: return True
            return bool(await self.evaluate_expression(expr.right, current_scope))
        if op == 'not':
            # 'not' is parsed as a binary op with a None lhs
            return not bool(await self.evaluate_expression(expr.right, current_scope))

        # Evaluate both operands for all other (non-short-circuiting) operators
        lhs = await self.evaluate_expression(expr.left, current_scope)
        rhs = await self.evaluate_expression(expr.right, current_scope)

        # Arithmetic, List, and String Operations
        try:
            if op == '+':
                if isinstance(lhs, list): return lhs + (rhs if isinstance(rhs, list) else [rhs])
                if isinstance(rhs, list): return ([lhs] if lhs is not None else []) + rhs
                if isinstance(lhs, str) or isinstance(rhs, str): return str(lhs or '') + str(rhs or '')
                return (lhs or 0) + (rhs or 0)
            if op == '-': return (lhs or 0) - (rhs or 0)
            if op == '*': return (lhs or 0) * (rhs or 0)
            if op == '/':
                # Correctly handle division by zero.
                # The original `rhs or 1` was hiding the error.
                if rhs is None or rhs == 0:
                    logger.warning(f"Division by zero attempted: {lhs} / {rhs}")
                    return None
                lhs_val = lhs or 0
                return lhs_val / rhs
        except TypeError:
            logger.warning(f"Type error in arithmetic operation: {lhs} {op} {rhs}")
            return None
        except ZeroDivisionError:
            logger.warning(f"Division by zero error: {lhs} / {rhs}")
            return None


        # Comparison Operators
        if op in ('==', 'eq'): return lhs == rhs
        if op in ('!=', 'ne'): return lhs != rhs
        if op == 'contains': return str(rhs) in str(lhs)
        if op == 'startswith': return str(lhs).startswith(str(rhs))
        if op == 'endswith': return str(lhs).endswith(str(rhs))

        # These comparisons can fail with TypeError if types are incompatible (e.g., 10 > "a")
        try:
            if op in ('>', 'gt'): return lhs > rhs
            if op in ('<', 'lt'): return lhs < rhs
            if op in ('>=', 'ge'): return lhs >= rhs
            if op in ('<=', 'le'): return lhs <= rhs
        except TypeError:
            return False

        logger.warning(f"Unsupported binary operator: {op}")
        return None

    async def visit_function_call_expr(self, expr: ActionCallExpr, current_scope: Dict[str, Any]) -> Any:
        """Evaluates a built-in function call within an expression."""
        func_name = expr.action_name.lower()

        if func_name in _BUILTIN_FUNCTIONS:
            func = _BUILTIN_FUNCTIONS[func_name]

            evaluated_args = []
            for arg_expr in expr.args:
                evaluated_args.append(await self.evaluate_expression(arg_expr, current_scope))

            try:
                # Built-in functions are regular synchronous python functions
                return func(*evaluated_args)
            except Exception as e:
                logger.error(f"Error executing built-in function '{func_name}': {e}")
                return None

        logger.warning(f"Unknown function called in expression: '{expr.action_name}'")
        return None

    async def _execute_action_legacy(self, action_node: Any):
        """Kept for reference, will be removed."""
        pass

    async def _resolve_path(self, path: str) -> Any:
        """
        Resolves a variable path (e.g., 'user.id', 'vars.group.my_var', 'command.arg[0]').
        This is the bridge between the script engine and the bot's live data.
        """
        path_lower = path.lower()

        # 1. Check for command variables (e.g., 'command.arg[0]')
        if path_lower.startswith('command.'):
            # This logic should only run for command events
            if not self.update.message or not self.update.message.text:
                return None

            message_text = self.update.message.text
            if not message_text.startswith('/'):
                return None

            cache_key = f"command_args_{self.update.update_id}"
            if cache_key not in self.per_request_cache:
                # Use shlex to correctly handle quoted arguments
                parts = shlex.split(message_text)
                command_name = parts[0].lstrip('/') # 移除命令前缀
                args = parts[1:]
                self.per_request_cache[cache_key] = {
                    "name": command_name,
                    "args": args,
                    "text": message_text,
                    "full_args": " ".join(args)
                }

            command_data = self.per_request_cache[cache_key]

            if path_lower == 'command.full_text':
                return command_data["text"]
            if path_lower in ('command.name', 'command.text'): # alias .text to .name
                return command_data["name"]
            if path_lower == 'command.full_args':
                return command_data["full_args"]
            if path_lower == 'command.arg_count':
                return len(command_data["args"])

            # Handle indexed access like command.arg[0]
            match = re.match(r'command\.arg\[(\d+)\]', path_lower)
            if match:
                arg_index = int(match.group(1))
                if 0 <= arg_index < len(command_data["args"]):
                    return command_data["args"][arg_index]

            return None # Return None for unknown command properties

        # 2. Check for persistent variables (`vars.scope.name`)
        if path_lower.startswith('vars.'):
            # (Implementation from old executor is preserved here)
            parts = path.split('.')
            if len(parts) != 3: return None
            _, scope, var_name = parts
            query = self.db_session.query(StateVariable).filter_by(group_id=self.update.effective_chat.id, name=var_name)
            if scope.lower() == 'user':
                if not self.update.effective_user: return None
                query = query.filter_by(user_id=self.update.effective_user.id)
            elif scope.lower() == 'group': query = query.filter(StateVariable.user_id.is_(None))
            else: return None

            variable = query.first()
            if variable:
                try:
                    return json.loads(variable.value)
                except json.JSONDecodeError:
                    return variable.value
            return None

        # 3. Check for special computed variables (e.g., 'user.is_admin')
        # (Implementation from old executor is preserved here)
        if path_lower == 'user.is_admin':
            if not (self.update.effective_chat and self.update.effective_user): return False
            cache_key = f"is_admin_{self.update.effective_user.id}"
            if cache_key in self.per_request_cache: return self.per_request_cache[cache_key]
            try:
                member = await self.context.bot.get_chat_member(chat_id=self.update.effective_chat.id, user_id=self.update.effective_user.id)
                is_admin = member.status in ['creator', 'administrator']
                self.per_request_cache[cache_key] = is_admin
                return is_admin
            except Exception:
                return False

        # 4. Resolve against the Telegram Update object
        # (Implementation from old executor is preserved here)
        base_obj, path_to_resolve = self.update, path
        current_obj = base_obj
        for part in path_to_resolve.split('.'):
            if current_obj is None: return None
            # Check for dict access first
            if isinstance(current_obj, dict):
                current_obj = current_obj.get(part)
            else:
                try:
                    current_obj = getattr(current_obj, part)
                except AttributeError:
                    return None
        return current_obj

    # =================== Action Implementations (Largely Unchanged) ===================
    # The actions themselves don't need much change. They just receive evaluated arguments.

    @action("reply")
    async def reply(self, text: Any):
        if self.update.effective_message:
            await self.update.effective_message.reply_text(str(text))

    @action("set_var")
    async def set_var(self, variable_path: str, value: Any):
        """
        Sets a persistent variable in the database, correctly handling JSON serialization.
        """
        if not isinstance(variable_path, str):
            return logger.warning(f"set_var 'variable_path' must be a string, but got {type(variable_path)}.")

        parts = variable_path.split('.')
        if len(parts) != 2:
            return logger.warning(f"set_var's variable path '{variable_path}' is invalid. Expected 'scope.name' format.")

        scope, var_name = parts[0].lower(), parts[1]
        if not self.update.effective_chat: return
        group_id = self.update.effective_chat.id
        user_id = None

        if scope == 'user':
            if not self.update.effective_user: return
            user_id = self.update.effective_user.id
        elif scope != 'group':
            return logger.warning(f"set_var has an invalid scope '{scope}'. Must be 'user' or 'group'.")

        variable = self.db_session.query(StateVariable).filter_by(
            group_id=group_id, user_id=user_id, name=var_name
        ).first()

        if value is None:
            if variable:
                self.db_session.delete(variable)
                logger.info(f"Persistent variable '{variable_path}' deleted.")
        else:
            try:
                # Ensure complex types (lists, dicts, bools) are stored as JSON text
                serialized_value = json.dumps(value)
            except TypeError as e:
                return logger.error(f"Failed to serialize value for '{variable_path}': {e}. Value: {value}")

            if not variable:
                variable = StateVariable(group_id=group_id, user_id=user_id, name=var_name)
            variable.value = serialized_value
            self.db_session.add(variable)
            logger.info(f"Persistent variable '{variable_path}' was set to: {serialized_value}")

    # (Other actions like mute_user, kick_user, etc., would be here, unchanged)
    # For brevity, I am omitting them, but they are part of the file.

    @action("delete_message")
    async def delete_message(self):
        """动作：删除触发此规则的消息。"""
        if self.update.effective_message:
            try:
                await self.update.effective_message.delete()
            except Exception as e:
                logger.error(f"删除消息失败: {e}")

    @action("start_verification")
    async def start_verification(self):
        """
        动作：为新用户开启人机验证流程。
        这包括：
        1. 立即将用户设置为受限模式（仅可读）。
        2. 向群组内发送一条带有 "开始验证" 按钮的消息。
        """
        if not (self.update.effective_chat and self.update.effective_user):
            return

        chat_id = self.update.effective_chat.id
        user_id = self.update.effective_user.id
        user_mention = self.update.effective_user.mention_html()
        bot_username = self.context.bot.username

        try:
            # 1. 将用户禁言
            await self.context.bot.restrict_chat_member(
                chat_id=chat_id,
                user_id=user_id,
                permissions=ChatPermissions(can_send_messages=False)
            )

            # 2. 发送验证链接
            verification_url = f"https://t.me/{bot_username}?start=verify_{chat_id}_{user_id}"
            keyboard = InlineKeyboardMarkup.from_button(
                InlineKeyboardButton(text="点此开始验证", url=verification_url)
            )
            await self.context.bot.send_message(
                chat_id=chat_id,
                text=f"欢迎 {user_mention}！为防止机器人骚扰，请在15分钟内点击下方按钮完成验证。",
                reply_markup=keyboard,
                parse_mode='HTML'
            )
        except Exception as e:
            logger.error(f"为用户 {user_id} 在群组 {chat_id} 启动验证时出错: {e}", exc_info=True)


    @action("stop")
    async def stop(self):
        raise StopRuleProcessing()
